/*

L-System layer

E - Energy
W - Water

A -> AB   [consumes 1 W 2 E]

A: implies update rule for CA
B: implies another update rule for the CA

CA layer

16 W 20 E
proportional update rule to propagate to parent and/or children

update rule used could be determined by the L-system node we're in.

state: energy and amount

Environmental Layer

root is the source of Water
end nodes evaporate Water
end nodes (any node?) generate E. Perhaps we could only make certain end nodes of type L generate E.
perhaps other nodes (for the stem? can still generate a little bit to have different strategies, or we could have leaves, needles, etc)

more sophisticated: only end nodes that can receive sunlight generate E,
sunlight vector, etc.

A node needs to consume a certain amount of E and W to be able to grow child nodes. To grow L could be more expensive than to grow non-L nodes.

A node needs to consume a certain amount of E and W to maintain itself.

Evolution layer

Generate a bunch of random rules (including CA consumption rules and transport rules)
R is the root node which is special, and can never be generated by evolution
L is the leaf node and is the only node that can generate E

The transport rules can be freely mutated and are proportions. Perhaps with upper limit?

Mutation step:
point mutation of rules
introduce new rule
remove rule
crossover between two sets of rules

Selection:

The plants which have managed to grow the most nodes are the most successful.

  A
 A    B
A  A  B   A

ABAABABABAABA

A -> BC

*/

export type RuleName = string

export enum Resource {
  water,
  energy,
}

export type ResourceCost = Map<Resource, number>

export class Environment {
  public costs(ruleNames: RuleName[]): ResourceCost {
    const waterCost = ruleNames.length * 10
    const energyCost = ruleNames.length * 10

    const cost = new Map<Resource, number>()
    cost.set(Resource.water, waterCost)
    cost.set(Resource.energy, energyCost)

    return cost
  }
}

export class Tree {
  public constructor(
    public rootNode: TreeNode,
    public lSystemRuleMap: LSystemRuleMap,
    public transportRuleMap: TransportRuleMap,
    public environment: Environment,
  ) { }

  public update(): void {
    this.rootNode.update(this)
  }
}

export class TreeNode {
  public children: TreeNode[] = []
  public resources = new Map<Resource, number>()

  public constructor(public name: RuleName, public parent: TreeNode | undefined) { }

  public update(tree: Tree) {
    // if we already have children, we update them recursively
    if (this.children.length !== 0) {
      this.updateResources()
      this.children.forEach(child => {
        child.update(tree)
      })

      return
    }
    // without children, try to grow new ones
    const lSystemRule = tree.lSystemRuleMap.get(this.name)
    if (lSystemRule == undefined) {
      this.updateResources()

      return
    }
    const childNames = lSystemRule.product
    const cost = tree.environment.costs(childNames)
    const canSpend = this.spendResources(cost)
    if (!canSpend) {
      this.updateResources()

      return
    }
    this.children = childNames.map(name => new TreeNode(name, this))
  }

  public toString(): string {
    const childrenStates = this.children.reduce(
      (result, child) => {
        return `${result}${String(child)}`
      },
      "",
    )

    return `${this.name}${childrenStates}`
  }

  private updateResources(): void {

  }

  private spendResources(cost: ResourceCost): boolean {
    for (const value of cost) {
      const resourceType = value[0]
      const resourceCost = value[1]
      const currentAmount = this.resources.get(resourceType)
      if (currentAmount == undefined) {
        if (resourceCost <= 0) {
          continue
        } else {
          return false
        }
      }
      if (resourceCost > currentAmount) {
        return false
      }
    }

    cost.forEach((resourceCost, resourceType) => {
      const currentAmount = this.resources.get(resourceType)
      if (currentAmount == undefined) {
        return
      }
      this.resources.set(resourceType, currentAmount - resourceCost)
    })

    return true
  }
}

export class LSystemRule {
  public constructor(public name: RuleName, public product: RuleName[]) { }
}

export type ResourceType = "Water" | "Energy"

export type ResourceMap = Map<ResourceType, number>

export class TransportRule {
  public constructor(
    public name: RuleName,
    public parentResourceMap: ResourceMap,
    public childResourceMap: ResourceMap,
  ) { }
}

export type LSystemRuleMap = Map<RuleName, LSystemRule>
export type TransportRuleMap = Map<RuleName, TransportRule>
