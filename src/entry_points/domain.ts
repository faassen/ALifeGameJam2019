/*

L-System layer

E - Energy
W - Water

A -> AB   [consumes 1 W 2 E]

A: implies update rule for CA
B: implies another update rule for the CA

CA layer

16 W 20 E
proportional update rule to propagate to parent and/or children

update rule used could be determined by the L-system node we're in.

state: energy and amount

Environmental Layer

root is the source of Water
end nodes evaporate Water
end nodes (any node?) generate E. Perhaps we could only make certain end nodes of type L generate E.
perhaps other nodes (for the stem? can still generate a little bit to have different strategies, or we could have leaves, needles, etc)

more sophisticated: only end nodes that can receive sunlight generate E,
sunlight vector, etc.

A node needs to consume a certain amount of E and W to be able to grow child nodes. To grow L could be more expensive than to grow non-L nodes.

A node needs to consume a certain amount of E and W to maintain itself.

Evolution layer

Generate a bunch of random rules (including CA consumption rules and transport rules)
R is the root node which is special, and can never be generated by evolution
L is the leaf node and is the only node that can generate E

The transport rules can be freely mutated and are proportions. Perhaps with upper limit?

Mutation step:
point mutation of rules
introduce new rule
remove rule
crossover between two sets of rules

Selection:

The plants which have managed to grow the most nodes are the most successful.

  A
 A    B
A  A  B   A

ABAABABABAABA

A -> BC

*/

export type RuleName = string

export enum Resource {
  water = "water",
  energy = "energy",
}

export type ResourceMap = Map<Resource, number>
export type ResourceCost = ResourceMap

function multiplyResourceMaps(resourceMap: ResourceMap, i: number): ResourceMap {
  const result = new Map<Resource, number>()
  resourceMap.forEach((value, key) => result.set(key, value * i))

  return result
}

function mergeResourceMaps(resourceMaps: ResourceMap[]): ResourceMap {
  const result = new Map<Resource, number>()
  resourceMaps.forEach((map, i) => {
    map.forEach((value, key) => {
      // tslint:disable-next-line: strict-boolean-expressions
      const currentValue = result.get(key) || 0
      result.set(key, currentValue + value)
    })
  })

  return result
}

export class Environment {
  public costs(ruleNames: RuleName[]): ResourceCost {
    return new Map<Resource, number>()
  }
}

export class Tree {
  public constructor(
    public rootNode: TreeNode,
    public lSystemRuleMap: LSystemRuleMap,
    public transportRuleMap: TransportRuleMap,
    public environment: Environment,
  ) { }

  public update(): void {
    this.rootNode.updateTree(this)
    this.rootNode.updateResourceState()
  }
}

export class TreeNode {
  public get depth(): number {
    if (this.parent == undefined) {
      return 0
    }

    return this.parent.depth + 1
  }
  public get nodeIndex(): string {
    if (this.parent == undefined) {
      return this.name
    }

    return `${this.parent.nodeIndex}${this.name}`
  }
  public children: TreeNode[] = []
  public resources = new Map<Resource, number>()  // should only be read once per each timestep
  public nextResources = new Map<Resource, number>()  // temporary save resource amount for the next timestep to not mix it to current one

  public constructor(public name: RuleName, public parent: TreeNode | undefined) { }

  public updateTree(tree: Tree) {
    // if we already have children, we update them recursively
    if (this.children.length !== 0) {
      this.children.forEach(child => {
        child.updateTree(tree)
      })
      this.updateResource(tree)

      return
    }
    // without children, try to grow new ones
    const lSystemRule = tree.lSystemRuleMap.get(this.name)
    if (lSystemRule == undefined) {
      this.updateResource(tree)

      return
    }
    const childNames = lSystemRule.product
    const cost = tree.environment.costs(childNames)
    const canSpend = this.canSpendResources(cost)
    if (!canSpend) {
      this.updateResource(tree)

      return
    }
    this.children = childNames.map(name => new TreeNode(name, this))
    this.spendResource(cost)
  }

  public updateResource(tree: Tree): void {
    const transportRule = tree.transportRuleMap.get(this.name)
    if (transportRule != undefined) {
      this.transportResources(transportRule)
    }
  }

  public updateResourceState(): void {
    this.resources = new Map<Resource, number>()
    this.nextResources.forEach((value, key) => this.resources.set(key, value))

    this.children.forEach(child => {
      child.updateResourceState()
    })
  }

  public toString(): string {
    const childrenStates = this.children.reduce(
      (result, child) => {
        return `${result}${String(child)}`
      },
      "",
    )

    return `${this.name}${childrenStates}`
  }

  private canSpendResources(cost: ResourceCost): boolean {
    for (const value of cost) {
      const resourceType = value[0]
      const resourceCost = value[1]
      if (resourceCost <= 0) {
        continue
      }
      const currentAmount = this.resources.get(resourceType)
      if (currentAmount == undefined || resourceCost > currentAmount) {
        return false
      }
    }

    return true
  }

  private spendResource(resourceMap: ResourceMap): void {
    resourceMap.forEach((resourceCost, resourceType) => {
      const currentAmount = this.nextResources.get(resourceType)
      if (currentAmount == undefined) {
        throw new Error(`[${this.nodeIndex}] Should not come here: fix the code. resource: ${resourceType}`)
      }
      const updatedAmount = currentAmount - resourceCost
      if (updatedAmount < 0) {
        throw new Error(`[${this.nodeIndex}] Should not come here: fix the code. resource: ${resourceType} updatedAmount: ${updatedAmount}`)
      }
      this.nextResources.set(resourceType, updatedAmount)
    })
  }

  private transportResources(rule: TransportRule): void {
    const resourceMap = mergeResourceMaps([
      rule.parentResourceMap,
      multiplyResourceMaps(rule.childResourceMap, this.children.length),
    ])
    if (this.canSpendResources(resourceMap) === false) {
      return
    }

    if (this.parent) {
      this.transportResourcesTo(this.parent, rule.parentResourceMap)
    }

    this.children.forEach(child => {
      this.transportResourcesTo(child, rule.childResourceMap)
    })
  }

  private transportResourcesTo(node: TreeNode, resourceMap: ResourceMap): void {
    resourceMap.forEach((value, resource) => {
      if (value <= 0) {
        return
      }
      const currentAmount = this.nextResources.get(resource)
      if (currentAmount == undefined || currentAmount - value < 0) {
        throw new Error(`[${this.nodeIndex}] Should not come here: fix the code. resource: ${resource} currentAmount: ${currentAmount}, value: ${value}, toNode: ${node.nodeIndex}`)
      }

      this.nextResources.set(resource, currentAmount - value)

      // tslint:disable-next-line: strict-boolean-expressions
      const parentAmount = node.nextResources.get(resource) || 0
      node.nextResources.set(resource, parentAmount + value)
    })
  }
}

export class TerrainNode extends TreeNode {
  // TODO: terrain node supplies water resource and parent of the root node
}

export class LSystemRule {
  public constructor(public name: RuleName, public product: RuleName[]) { }
}

export class TransportRule {
  public constructor(
    public name: RuleName,
    public parentResourceMap: ResourceMap,
    public childResourceMap: ResourceMap,
  ) { }
}

export type LSystemRuleMap = Map<RuleName, LSystemRule>
export type TransportRuleMap = Map<RuleName, TransportRule>
